package info.danbecker.dba;

import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.atn.ATN;
import org.antlr.v4.runtime.misc.Utils;
import org.antlr.v4.runtime.tree.*;

import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Stream;

/**
 * An Army is a list or group of elements as given in the DBA Army lists on DBA 3.0 page 133.
 * For example the Army referenced by III/17 has the following grammar:
 * <code>
 * 1x(Cv/6Cv),5x(6Cv/Cv),3xLH or Sp,2xLH or 4Bw or Ps,1x3Kn or Ps or Art
 * </code>
 * <p>
 * Commas delimit a list, x represents multiples, ( ) represents groups, / and //
 * + and or represent alternatives, and the codes represent element types.
 * <p>
 * The Army class interacts with the DBAArmy grammar, parser, and scanner
 * generated by the ANTLR4 tool to read lists and report on legal combinations and instantiations.
 * <p>
 * {@code @TODO} Very verbose @getUnitList, @matches, @permute. Make visitor pattern. However they return exprs, bools, Strings.
 * <p>
 * {@code @TODO} Eventually the ArmyHeaderBean (with group name) and
 * the Army variants (with army versions, different names, date)
 * must be refactored into proper entities and relations.
 *
 * @author <a href="mailto://dan@danbecker.info>Dan Becker</a>
 * @version DBA30
 */
public class Army implements Comparable<Army> {
    // Number encodes solid or fast for  PK, BD, AX, BW, WB, HD
    // Psiloi and foot that are listed as 3, 5 or 6 to a base are classed as “Fast” or “Solid” (page 33)
    // DBMM encodes S=Superior, O=Ordinary, F=Fast, I=Inferior, X=Exception
    static Logger LOGGER = Logger.getLogger(Army.class.getName());

    final String armyStr;
    ParseTree tree = null;
    DBAArmyParser parser = null;

    static List<String> ruleNames;
    static {
        LOGGER.setLevel(Level.FINEST);
        LOGGER.fine( "Army parser initialization");
        CharStream charStream = CharStreams.fromString("Ps");
        DBAArmyLexer lexer = new DBAArmyLexer(charStream);
        CommonTokenStream tokenStream = new CommonTokenStream(lexer);
        DBAArmyParser parser = new DBAArmyParser(tokenStream);
        // String[] tokenNames = parser.getTokenNames();
        // Arrays.asList(tokenNames).forEach( System.out::println  );
        // '5Hd' 'Hd' 'Art' 'WWg', ..
        ruleNames = Arrays.asList(parser.getRuleNames());
    }

    // See DBAArmy.g4 for grammar
    public Army(String armyStr) {
        if (null == armyStr) throw new IllegalArgumentException("input string is null");
        if (armyStr.isEmpty()) throw new IllegalArgumentException("input string is empty");
        if (armyStr.isBlank()) throw new IllegalArgumentException("input string is blank");
        this.armyStr = armyStr;
        parse();
    }

    /**
     * Return a List of all the units in an army.
     * @return List of all the units in an army
     */
    public List<String> getUnitList() {
        return getUnitList( this.tree );
    }

    /**
     * Return a List of all the unit Strings in a parse tree.
     * <p>
     * The list is not sorted or de-deduped.
     * <p>>
     * For example "Cv//4Wb,7x4Wb,3x3Bw or 7Hd,1xPs" returns
     * [ "Cv", "4Wb", "4Wb", "3Bw", "7Hd", "Ps"]
     * <p>
     * Note that some expression have multiple counts
     * Bd or 2xBd or 4xBd -> 1 or 2 or 4 and returns ["Bd"]
     * </p>
     * @return List of all the unit Strings in a parse tree
     */
    public static List<String> getUnitList(ParseTree tree) {
        final List<String> units = new ArrayList<>();
        // Walk the tree, gather units
        ParseTreeWalker walker = new ParseTreeWalker();
        walker.walk(new DBAArmyBaseListener() {
            // finds type leaves
            @Override
            public void exitType(DBAArmyParser.TypeContext ctx) {
                units.add(ctx.getText());
                // System.out.println("DBA type: " + ctx.getText());
            }

        }, tree);
        return units;
    }

    /**
     * Determines whether the given army is an
     * instance of this army.
     * For example, is this army is from a list
     * <code>
     * 1x(Cv/6Cv),5x(6Cv/Cv),3xLH or Sp,2xLH or 4Bw or Ps,1x3Kn or Ps or Art
     * </code>
     * and the given army is
     * <code>
     * Cv,5xCv,3xSp,xLH,Art
     * </code>
     * the return is true.
     * <p>
     * Illegal instances return false.
     *
     * @param army is an instance of this
     * @return whether the given army is an instance of this Army
     */
    public boolean isInstance(Army army) {
        return matchTree( this.tree, army.tree );
    }

    /**
     * Parse the given string and see if it is an instance of this army.
     * @param instStr an Army String
     * @return whether given String matches this
     */
    public boolean isInstance(String instStr) {
        return isInstance(new Army(instStr));
    }

    /**
     * Returns the count of subStr occurring in the String text
     * @param subStr to be found
     * @param text to be searched
     * @return count of subStr occurring in the String text
     */
    public static int subStringCount( String subStr, String text) {
        // Count delimiters
        int count = 0;
        int index = 0;
        while (-1 != index) {
            index = text.indexOf(subStr, index);
            if (-1 != index) {
                count++;
                index += subStr.length();
            }
        }
        return count;
    }

    /**
     * This is the one-time parsing of the given army String.
     * Only called during constructor.
     */
    protected void parse() {
        // this.armyStr = "Kn/(LCh or WWg)";
        CharStream charStream = CharStreams.fromString(armyStr);
        DBAArmyLexer lexer = new DBAArmyLexer(charStream);
        CommonTokenStream tokenStream = new CommonTokenStream(lexer);
        this.parser = new DBAArmyParser(tokenStream);

        // Listeners are invoked by ANTLR provided walkers
        // Visitors are invoked by user-provided tree walkers.
        // List<ParseTreeListener> listeners = parser.getParseListeners();
        parser.addParseListener(new DBAArmyBaseListener() {
            @Override
            public void exitExprEither(DBAArmyParser.ExprEitherContext ctx) {
                // exprEither cardinality check
                String text = ctx.getText();
                int count = subStringCount( ctx.EITHER_DELIM().getText(), text );
                // System.out.println( "ctx text=" + ctx.getText() + ", delimCount=" + count );
                if ( 2 <= count ) {
                    throw new IllegalArgumentException("Parse error exprEither cardinality " + count + " exceeded at  \"" + text + "\"" );
                }
            }
        });
        parser.addParseListener(new DBAArmyBaseListener() {
            @Override
            public void exitExprDismount(DBAArmyParser.ExprDismountContext ctx) {
                // exprDismount cardinality check
                String text = ctx.getText();
                int count = subStringCount( ctx.DISMOUNT_DELIM().getText(), text );
                // System.out.println( "ctx text=" + ctx.getText() + ", delimCount=" + count );
                if ( 2 <= count ) {
                    throw new IllegalArgumentException("Parse error exprDismount cardinality " + count + " exceeded at  \"" + text + "\"" );
                }
            }
        }
        );
        // List<? extends ANTLRErrorListener> errorListeners = parser.getErrorListeners(); // ConsoleErrorListener
        // A listener designed to catch and rethrow parse errors, similar to constructor IllegalArgumentExceptions.
        parser.removeErrorListeners(); // Typical output "line 1:3 missing ')' at '<EOF>'"
        parser.addErrorListener(new BaseErrorListener() {
            @Override
            public void syntaxError(Recognizer<?, ?> recognizer, Object offendingSymbol, int line, int pos, String msg, RecognitionException e) {
                // Typical output "Parse error:"(Ps" at pos 3:  missing ')' at '<EOF>'
                throw new IllegalArgumentException("Parse error \"" + armyStr + "\", pos " + pos + ": " + msg, e);
            }
        });
        this.tree = parser.exprs();
        // System.out.println(tree.toStringTree(parser)); // print LISP-style tree
    }

    @Override
    public boolean equals(Object obj) {
        if (null == obj) return false;
        if (!(obj instanceof Army)) return false;
        return this.toString().equals(obj.toString());
    }

    @Override
    public int hashCode() {
        return toString().hashCode();
    }

    @Override
    public int compareTo(Army that) {
        if (null == that) return -1;
        return this.toString().compareTo(that.toString());
    }

    /**
     * Returns the raw String handed to and parsed at the parse entry point, eg " ( Ps)"
     * Distinguish from toString() which is a canonical form of the String, eg "(Ps)"
     *
     * @return raw String handed to and parsed at the parse entry point
     */
    public String getString() {
        return this.armyStr;
    }

    /**
     * Convert an element to a string.
     * The parse and toString APIs are reciprocal.
     */
    @Override
    public String toString() {
        if (null == armyStr) return "null";
        return Army.toStringTree(this.tree);
    }

    // Essentially a streamlined version of
    // https://github.com/antlr/antlr4/blob/67228355c5bfd1ed5ebb89e726992ec43dda7b53/runtime/Java/src/org/antlr/v4/runtime/tree/Trees.java#L70
    /**
     * Print out a whole tree in DBA format.
     * <p>Similar to Trees.toStringTree, but a more streamlined tree.
     * Tree.toStringTree returns a LISP type String: (expressions (expression (type (psiloi Ps))))
     * This toStringTree returns a more bare String: Ps
     * <p>
     * {@link #getNodeText} is used on the node payloads to get the text for the nodes.
     */
    protected static String toStringTree(final Tree t) {
        String s = Utils.escapeWhitespace(getNodeText(t, false), false);
        if (t.getChildCount() == 0) return s;
        StringBuilder buf = new StringBuilder();
        // buf.append("(");
        s = Utils.escapeWhitespace(getNodeText(t, false), false);
        buf.append(s);
        // buf.append(' ');
        for (int i = 0; i < t.getChildCount(); i++) {
            // if ( i>0 ) buf.append(' ');
            buf.append(toStringTree(t.getChild(i)));
        }
        // buf.append(")");
        return buf.toString();
    }

    /** Return the String of a tree node
     * @param t the tree node
     * @param fullRuleNames true returns rule names, false returns "" for rule names.
     * @return the String of a tree node
     */
    protected static String getNodeText(Tree t, boolean fullRuleNames) {
        if (t instanceof RuleContext) {
            if (fullRuleNames) {
                int ruleIndex = ((RuleContext) t).getRuleContext().getRuleIndex();
                String ruleName = ruleNames.get(ruleIndex);
                int altNumber = ((RuleContext) t).getAltNumber();
                if (altNumber != ATN.INVALID_ALT_NUMBER) {
                    // If the grammar has "bows = bow | crossbow | lightbow"
                    // Rule will return bows:1 or bows:2 or bows:3 depending on the child.
                    return ruleName + ":" + altNumber;
                }
                return ruleName;
            }
            return "";
        // } else if (t instanceof ParserRuleContext) {  // always false?
        //     return t.getClass().getName();
        } else if (t instanceof TerminalNode) {
            Token symbol = ((TerminalNode) t).getSymbol();
            if (symbol != null) {
                return symbol.getText(); // delimiters such as () /, also Ps, Cv
            }
        }

        // Army does not allow ErrorNodes, throws an IllegalArgumentException.
        // I don't think DBAArmy ever gets here.
        // The payload is either a Token or a RuleContext object.
        Object payload = t.getPayload();
        if (payload instanceof Token) {
            return ((Token) payload).getText();
        }
        return t.getPayload().toString();
    }

    /**
     * Check to see that all test army units exist in this army.
     *
     * @param test Army provider of units
     * @return whether all test army units exist in this army.
     */
    public boolean containsAllUnits(Army test) {
        List<String> myUnits = this.getUnitList();
        List<String> testUnits = test.getUnitList();
        for (String testUnit : testUnits) {
            if (!myUnits.contains(testUnit)) {
                // System.out.println( "Test unit \"" + testUnit + "\" not in target " + myUnits );
                return false;
            }
        }
        return true;
    }

    public boolean containsAllUnits(String testStr) {
        Army test = new Army(testStr);
        return containsAllUnits(test);
    }

    /** Returns a list of all expr in this tree.
     * <p>
     * This is particularly useful for exprs, exprAnd, and exprOr
     * and other recursive structures with grammar rule
     * <code>
     *    expr (LIST_DELIM expr)*
     *    expr (AND_DELIM expr)+        #exprAnd
     *    expr (OR_DELIM expr)+         #exprOr
     * </code
     * which have a required first element and an endless LR tail.
     * <p>
     * The switch tree has been populated to work
     * with other grammar cases that include expr.
     * <code>
     *   GROUP_OPEN expr GROUP_CLOSE   #exprGroup
     *   expr DISMOUNT_DELIM expr      #exprDismount
     *   expr EITHER_DELIM expr        #exprEither
     *  INTEGER MULTIPLE_DELIM expr   #exprMultiple
     * </code>
     *
     * @param tree with children having expr
     * @return List of Tree of expr or empty List
     */
    public static List<Tree> getAllExprs(Tree tree) {
        // Categorize and permute. May recurse or continue to children.
        switch (tree) {
            case DBAArmyParser.ExprsContext exprs -> {
                List<DBAArmyParser.ExprContext> exprList = exprs.expr();
                // Go one deeper if this is a single expr
                if ( 1 == exprList.size() )
                    return getAllExprs( exprList.getFirst() );
                // List<ExprContext> -> ParserRuleContext -> ParseTree -> Tree
                return exprList.stream()
                        .map( t -> (Tree) t)
                        .toList();
            }
            case DBAArmyParser.ExprGroupContext exprGroup -> {
                System.out.println("getAllExpr exprGroup");
                return List.of(exprGroup.expr());
            }
            case DBAArmyParser.ExprDismountContext dismount -> {
                System.out.println("getAllExpr exprDismount");
                // Pass back as a single indivisible element, or two parts
                return List.of( dismount.expr(0), dismount.expr(1));
            }
            case DBAArmyParser.ExprAndContext exprAnd -> {
                List<Tree> children = new ArrayList<>();
                Tree first = exprAnd.expr(0);
                if ( first instanceof DBAArmyParser.ExprAndContext) {
                    List<Tree> firsts = getAllExprs( first );
                    children.addAll( firsts );
                }
                else children.add( first );
                Tree second = exprAnd.expr(1 );
                if ( second instanceof DBAArmyParser.ExprAndContext) {
                    List<Tree> seconds = getAllExprs( second );
                    children.addAll( seconds );
                }
                else children.add( second );
                return children;
            }
            case DBAArmyParser.ExprEitherUnitContext exprEitherUnit -> {
                System.out.println("getAllExpr exprEitherUnit");
                int firstUnitNum = Integer.parseInt(exprEitherUnit.INTEGER().getText());
                DBAArmyParser.TypeContext type = exprEitherUnit.type();
                List<String> numUnit = getNumCharGroups( type.getText() );
                Army army = new Army( firstUnitNum + numUnit.getLast() );
                return List.of( army.tree, type);
            }
            case DBAArmyParser.ExprEitherContext exprEither -> {
                System.out.println("getAllExpr exprEither");
                // Pass back as a single indivisible element, or two parts
                return List.of( exprEither.expr(0), exprEither.expr(1));
            }
            case DBAArmyParser.ExprOrContext exprOr-> {
                List<Tree> children = new ArrayList<>();
                Tree first =exprOr.expr(0);
                if ( first instanceof DBAArmyParser.ExprOrContext) {
                    List<Tree> firsts = getAllExprs( first );
                    children.addAll( firsts );
                }
                else children.add( first );
                Tree second = exprOr.expr(1 );
                if ( second instanceof DBAArmyParser.ExprOrContext) {
                    List<Tree> seconds = getAllExprs( second );
                    children.addAll( seconds );
                }
                else children.add( second );
                return children;
            }
            // might want to match 3Wb or 4Wb and 3Wb/4Wb
            case DBAArmyParser.ExprMultipleContext mult -> {
                System.out.println("getAllExpr exprMultiple");
                 return List.of( mult.expr() );
            }
            case DBAArmyParser.ExprTypeContext exprType -> {
                return List.of( exprType );
            }
            // case TerminalNode terminalNode -> {
            //     return List.of( terminalNode );
            // }
            // case RuleContext rule -> {
            // }
            // case ErrorNode eNode -> {
            // Army does not get here since the constructor throws IllegalArgumentException
            // return t.toString();
            // }
            default -> System.out.println("getAllExpr unknown tree " + toStringTree(tree));
        }
        return List.of();
    }

    /**
     * The high level starting point to determine if this
     * army matches the units of another army.
     */
    public boolean matches(Army test) {
        // Easily found by matching all the way down to units.
        // if ( !containsAllUnits( test )) return false;
        System.out.println(tree.toStringTree(parser)); // print LISP-style tree
        System.out.println(test.tree.toStringTree(parser)); // print LISP-style tree

        return matchTree(this.tree, test.tree );
    }

    public boolean matches(String testStr) {
        Army test = new Army(testStr);
        return matches(test);
    }

    /**
     * Converts a tree node expression of type exprEitherUnit (such as 3/4Bd)
     * into an equivalent expression of type exprEither (such as 3Bd/4Bd).
     * @param t provider Tree of expression
     * @return same tree or promoter either unitzs
     */
    public static Tree promoteExprEitherUnit(Tree t ) {
        if ( t instanceof DBAArmyParser.ExprEitherUnitContext ) {
            DBAArmyParser.ExprEitherUnitContext eitherUnit = (DBAArmyParser.ExprEitherUnitContext) t;
            int num = Integer.parseInt(eitherUnit.INTEGER().getText());
            String secondTypeStr = eitherUnit.type().getText();
            List<String> numChars = getNumCharGroups( secondTypeStr );
            String firstTypeStr = switch ( numChars.size()) {
                case 2: yield num + numChars.get(1);
                case 1: yield num + numChars.get(0);
                default: yield "";
            };
            if ( !firstTypeStr.isEmpty()) {
                // Replace 3/4Wb node with 3Wb/4Wb node.
                String armyStr = firstTypeStr + eitherUnit.EITHER_DELIM().getText() + secondTypeStr;
                System.out.println("Promoting exprEitherUnit \""+ eitherUnit.getText() + "\" to exprEither \"" + armyStr + "\"");
                Army army = new Army( armyStr );
                t = ((DBAArmyParser.ExprsContext)army.tree).expr(0);
                System.out.println("exprEither=" + army.tree.toStringTree(army.parser));
            } else {
                System.out.println("Could not figure promotion of exprEitherUnit \""+ eitherUnit.getText() + "\"" );
            }
        }
        return t;
    }

    /**
     * Converts a tree node expression of type exprMultiple with 1x (such as 1x4Bd or 1x(Bd + Wb))
     * into an equivalent expression of type expr (such as 4Bd or (Bd+Wb) ).
     * @param t Tree to test
     * @return promoted tree or original
     */
    public static Tree promoteExprMultiple1x(Tree t ) {
        if ( t instanceof DBAArmyParser.ExprMultipleContext ) {
            DBAArmyParser.ExprMultipleContext mult = (DBAArmyParser.ExprMultipleContext) t;
            int multi = Integer.parseInt(mult.INTEGER().getText());
            if (1 == multi) {
                System.out.println("Promoting 1x exprMultiple \""+ mult.getText() + "\" to \"" + mult.expr().getText() + "\"");
                return mult.expr();
            }
        }
        return t;
    }

    /** Splits a string such as 4Wb into [ "4", "Wb" ]
     * @param str input to split such as 4Wb
     * @return List of split String [ "4", "Wb" ]
     */
    public static List<String> getNumCharGroups(String str) {
        List<String> output = new ArrayList<>();
        Matcher match = Pattern.compile("[0-9]+|[A-Za-z]+").matcher(str);
        while (match.find()) {
            output.add(match.group());
        }
        return output;
    }

    /**
     * Determine the two trees match each other.
     * Given an army with options
     * <code>Gen+Cv,5xCv,3xCv or LH,1xLH or Ps,2xCv or 2x7Hd or (1x7Hd + 1x4Wb)</code> // III/18
     * the following pass:
     * <code>Gen+Cv,5xCv,3xLH,Ps,1x4Wb+1x7Hd       Gen+Cv,5xCv,3xCv,LH,2xCv</code>
     * the following do not pass:
     * <code>Cv,4xCv,5xLH,Wb,3x7Hd                 Gen+Cv,5xKn,3xCv,Bw,2xCv</code>
     * <p>
     * The general process is:
     * <ul>
     * <li>promote or convert simple expressions such as groups or exprEitherUnit</li>
     * <li>categorize and match expressions where possible</li>
     * <li>visit child nodes (in any order) to continue matching</li>
     * </ul>
     */
    public static boolean matchTree(final Tree ft, final Tree fthat) {
        Tree t = ft;
        Tree that = fthat;

        // Instead of this iterative promoting, might
        // want to handle it right at the type switch.
        // Possible convert exprMultiple with 1x to expr
        t = promoteExprMultiple1x( t );
        that = promoteExprMultiple1x( that );
        t = promoteExprEitherUnit( t );
        that = promoteExprEitherUnit( that );
        // Promote exprGroup to simpler expr
        while(t instanceof DBAArmyParser.ExprGroupContext) {
            System.out.println("Elevating this groupRule " + toStringTree( t ) + " to " + toStringTree( ((DBAArmyParser.ExprGroupContext) t).expr() ));
            t = ((DBAArmyParser.ExprGroupContext) t).expr();
        }
        while(that instanceof DBAArmyParser.ExprGroupContext) {
            System.out.println("Elevating that groupRule " + toStringTree( that ) + " to " + toStringTree( ((DBAArmyParser.ExprGroupContext) that).expr() ));
            that = ((DBAArmyParser.ExprGroupContext) that).expr();
        }
        t = promoteExprMultiple1x( t );
        that = promoteExprMultiple1x( that );

        // Categorize and match. May recurse or continue to children.
        switch (t) {
            case DBAArmyParser.ExprsContext exprs -> {
                // System.out.println("Matching " + getNodeText(exprs, true) + " to " + getNodeText(that, true));
                if (!(that instanceof DBAArmyParser.ExprsContext)) {
                    System.out.println("Mismatched rules " + getNodeText(exprs, true) + " to " + getNodeText(that, true));
                    return false;
                }
                DBAArmyParser.ExprsContext thatExprs = (DBAArmyParser.ExprsContext) that;
                if (exprs.getChildCount() != thatExprs.getChildCount()) {
                    System.out.println("Mismatched exprs counts " + exprs.getChildCount() + " to " + thatExprs.getChildCount());
                    return false;
                }
                int childCount = exprs.getChildCount();
                String childCountStr = ", " + childCount + (1==childCount ? " child." : " children.");
                System.out.println("Matching " + getNodeText(exprs, true) + " to " + getNodeText(that, true) + childCountStr );
                // Let this fall to any-order child matching
            }
            case DBAArmyParser.ExprEitherContext either -> {
                System.out.println("Matching exprEither " +  toStringTree( either )+ " to " + toStringTree( that ) );
                if ( that instanceof DBAArmyParser.ExprEitherContext ) {
                    DBAArmyParser.ExprEitherContext thatExprEither = (DBAArmyParser.ExprEitherContext) that;
                    // Allow either expressions to match in any order.
                    return ((matchTree( either.expr(0), thatExprEither.expr(0)) &&
                             matchTree( either.expr(1), thatExprEither.expr(1))) ||
                            (matchTree( either.expr(0), thatExprEither.expr(1)) &&
                             matchTree( either.expr(1), thatExprEither.expr(0))));
                }
                return matchTree( either.expr(0), that) || matchTree( either.expr(1), that);
            }
            case DBAArmyParser.ExprDismountContext dismount -> {
                // Unlike either where Cv/Bd == Bd/Cv, dismount Cv//Bd != Bd//Cv, similarly Cv//Bd != Cv
                System.out.println("Matching exprDismount " +  toStringTree( dismount )+ " to " + toStringTree( that ) );
                if ( that instanceof DBAArmyParser.ExprDismountContext ) {
                    DBAArmyParser.ExprDismountContext thatExprDismount = (DBAArmyParser.ExprDismountContext) that;
                    // Dismount expressions must match order.
                    return matchTree( dismount.expr(0), thatExprDismount.expr(0)) &&
                         matchTree( dismount.expr(1), thatExprDismount.expr(1));
                }
                return false;
            }
            case DBAArmyParser.ExprAndContext exprAnd -> {
                System.out.println("Matching exprAnd " +  toStringTree( exprAnd )+ " to " + toStringTree( that ) );
                DBAArmyParser.ExprContext thisA = exprAnd.expr(0);
                DBAArmyParser.ExprContext thisB = exprAnd.expr(1);
                if ( that instanceof DBAArmyParser.ExprAndContext ) {
                    // Matching exprAnd Ax+Bd to Bd+Ax
                    // Also matching exprAnd Ax+Bd+Cv to Ax+Cv+Bd
                    DBAArmyParser.ExprAndContext thatExprAnd = (DBAArmyParser.ExprAndContext) that;
                    DBAArmyParser.ExprContext thatA = thatExprAnd.expr(0);
                    DBAArmyParser.ExprContext thatB = thatExprAnd.expr(1);
                    if ((matchTree( thisA, thatA ) && matchTree( thisB, thatB )) ||
                           (matchTree( thisA, thatB ) && matchTree( thisB, thatA ))) {
                        return true;
                    }
                    // Swap tail to see if that matches
                    if (( thisA instanceof DBAArmyParser.ExprAndContext ) &&
                        ( thatA instanceof DBAArmyParser.ExprAndContext )) {
                        return matchTreesAnyOrder( getAllExprs( exprAnd ), getAllExprs(thatExprAnd), true );
                    }
                }
                else if  ( that instanceof DBAArmyParser.ExprOrContext ) {
                    // Matching thisA+thisB to thatC or thatA+thatC?
                    // Also matching thisA+thisB to thatA+thatB or thatC?
                    DBAArmyParser.ExprOrContext thatExprOr = (DBAArmyParser.ExprOrContext) that;
                    DBAArmyParser.ExprContext thatA = thatExprOr.expr(0);
                    DBAArmyParser.ExprContext thatB = thatExprOr.expr(1);
                    return matchTree( exprAnd, thatA ) || matchTree( exprAnd, thatB );
                    // matchTreesAnyOrder(exprAnd, thatExprOr, false);
                }
                return false;
            }
            case DBAArmyParser.ExprOrContext exprOr -> {
                System.out.println("Matching exprOr " + toStringTree(exprOr) + " to " + toStringTree(that));
                DBAArmyParser.ExprContext thisA = exprOr.expr(0);
                DBAArmyParser.ExprContext thisB = exprOr.expr(1);
                if (that instanceof DBAArmyParser.ExprOrContext) {
                    // Matching exprOr Ax or Bd to Bd or Ax
                    // Also matching exprOr Ax or Bd or Cv to Ax or Cv or Bd
                    DBAArmyParser.ExprOrContext thatExprOr = (DBAArmyParser.ExprOrContext) that;
                    DBAArmyParser.ExprContext thatA = thatExprOr.expr(0);
                    DBAArmyParser.ExprContext thatB = thatExprOr.expr(1);
                    return matchTree( thisA, thatA ) || matchTree( thisA, thatB ) ||
                            matchTree( thisB, thatA ) || matchTree( thisB, thatB );
                }
                else if (that instanceof DBAArmyParser.ExprEitherContext ) {
                    // Matching exprOr Ax or Bd to Bd or Ax
                    // Also matching exprOr Ax or Bd or Cv to Ax or Cv or Bd
                    DBAArmyParser.ExprEitherContext thatExprOr = (DBAArmyParser.ExprEitherContext) that;
                    DBAArmyParser.ExprContext thatA = thatExprOr.expr(0);
                    DBAArmyParser.ExprContext thatB = thatExprOr.expr(1);
                    return matchTree( thisA, thatA ) || matchTree( thisA, thatB ) ||
                            matchTree( thisB, thatA ) || matchTree( thisB, thatB );
                }
                return matchTree( thisA, that ) || matchTree( thisB, that );
            }
            case DBAArmyParser.ExprMultipleContext mult -> {
                // 1x exprMultiples are promoted to expr above.
                System.out.println("Matching exprMulti " + toStringTree( mult ) + " to " + toStringTree(that));
                if ( that instanceof DBAArmyParser.ExprMultipleContext ) {
                    DBAArmyParser.ExprMultipleContext thatMult = (DBAArmyParser.ExprMultipleContext) that;
                    int multi = Integer.parseInt(mult.INTEGER().getText());
                    int thatMulti = Integer.parseInt(thatMult.INTEGER().getText());
                    if (multi != thatMulti) {
                        System.out.println("Mismatched multi counts " + multi + "x" + mult.expr().getText() + " != " + thatMulti + "x" + thatMult.expr().getText());
                        return false;
                    }
                    return matchTree( mult.expr(), thatMult.expr() );
                }
                return false;
            }
            // case DBAArmyParser.ExprContext expr -> {
                // Matched by other rules
                // System.out.println("Matching expr " + getNodeText( expr, true) + " to " + getNodeText(that, true));
                // Let this fall to child matching
            //}
            //case DBAArmyParser.ExprGroupContext groupRule -> {
            //   Group expr payloads are elevated at the beginning of this method.
            //   ExprGroupContext should not be reached.
            //}
            case DBAArmyParser.ExprTypeContext exprType -> {
                // System.out.println("Matching exprType " +  toStringTree(exprType)+ " to " + toStringTree(that));
                if ( that instanceof DBAArmyParser.ExprTypeContext ) {
                    DBAArmyParser.ExprTypeContext thatType = (DBAArmyParser.ExprTypeContext) that;
                    // System.out.println("Matching exprType " + exprType.getText() + " to " + thatType.getText() );
                    return exprType.getText().equals( thatType.getText() );
                } else if ( that instanceof DBAArmyParser.ExprOrContext ) {
                    return matchTree( that, exprType );
                }
                return false;
            }
            // case RuleContext rule -> {
                // With exprType above, this is never hit.
                // Shows non-explicit rule matches which need child matching only.
                // System.out.println( "Matching rule " + getNodeText(rule, true) + " to " + getNodeText(that, true));
                // Let this fall to child matching
            // }
            case TerminalNode terminalNode -> {
                // This rule only hits exprs child token matching, ie ","
                // Can use DBAArmyLexer.VOCABULARY.getLiteralNames() or .getSymbolicNames() for the list
                // "'Hd'", "'Art'", "'WWg'", "','", "'x'", "'//'", "'/'", "'or'", "'+'", // example literal names
                // "EITHER_DELIM", "OR_DELIM", "AND_DELIM", "GROUP_OPEN", "GROUP_CLOSE", "INTEGER", "WS" // example symbolic
                // System.out.println("Matching terminal " + getNodeText(t, true) + " to " + getNodeText(that, true));
                String text = terminalNode.getText();
                if (!(that instanceof TerminalNode thatTerminalNode)) {
                    // System.out.println("Mismatched terminal " + text + " to " + getNodeText(that, true));
                    return false;
                }
                String thatText = thatTerminalNode.getText();
                return text.equals(thatText);
                // String matchStr = match ? " matches " : " does not match ";
                // System.out.println("Terminal text " + text + matchStr + thatText);
                // return match;
            }
            // Army does not get here since the constructor throws IllegalArgumentException
            // else if ( t instanceof ErrorNode) {
            //    return t.toString();
            // }
            default -> System.out.println("Unmatched tree " + toStringTree( t ));
        }

        // Visit and match children in any order.
        return matchChildrenAnyOrder( t, that );
    }

    /** Match the children of two trees.
     * Allow matches to happen in any order to support commutativity.
     * In other words, allow Bd,Sp,Bw to match Bw,Bd,Sp or Wb+Bw to match Bw+Wb.
     * @param trees List of Trees
     * @param thats List of Trees
     * @param completeMatch whether thats must be a complete match or just a subset
     * @return whether the trees match in any order
     */
    public static boolean matchTreesAnyOrder(final List<Tree> trees, final List<Tree> thats, boolean completeMatch) {
        if (completeMatch && (trees.size() != thats.size()))
            return false;
        // Build a list of indexes of unmatched children.
        List<Integer> unmatchedThats = new ArrayList<>();
        for (int j = 0; j < thats.size(); j++) unmatchedThats.add(j);

        for (int treei = 0; treei < trees.size(); treei++) {
            int matchi = matchTreeFirst(trees.get(treei), thats, unmatchedThats);
            if (completeMatch) {
                // Could not match this treei to any unmatchedChildis.
                if (-1 == matchi)
                   return false;
            } else {
                // !completeMatch
                if (-1 != matchi)
                    return true;
            }
            // Remove the matchi from the unmatchedChildis
            unmatchedThats.remove((Integer) matchi); // remove integer, not index!
        }
        // All thats tested, still here with no short circuits
        return completeMatch;
    }

    /**
     * Matches t with one of List<Tree> of that.
     * @return thats.get(treeis) integer of match with t, or -1 for no match.
     */
    public static int matchTreeFirst(final Tree t, final List<Tree> thats, final List<Integer> treeis) {
        for (int i : treeis) {
            if (matchTree(t, thats.get(i))) {
                return i;
            }
        }
        return -1;
    }

    /** Match the children of two trees.
     * Allow matches to happen in any order to support commutativity.
     * In other words, allow Bd,Sp,Bw to match Bw,Bd,Sp or Wb+Bw to match Bw+Wb.
     * @param tree Tree of children
     * @param that Tree to match one of Three children
     * @return whether the child lists have a match or -1 for not.
     */
    public static boolean matchChildrenAnyOrder(final Tree tree, final Tree that) {
        // Build a list of indexes of unmatched children.
        List<Integer> unmatchedChildis = new ArrayList<>();
        for (int j = 0; j < that.getChildCount(); j++) unmatchedChildis.add(j);

        for (int myChildi = 0; myChildi < tree.getChildCount(); myChildi++) {
            int matchi = matchTreeFirstChild(tree.getChild(myChildi), that, unmatchedChildis);
            if (-1 == matchi) {
                // Could not match myChildi to any unmatchedChildis.
                // System.out.format( "Child %d/%d of this tree %s did not match\n",
                //         i, t.getChildCount(), getNodeText( t.getChild(i), true ));
                return false;
            } else {
                // Matched myChildi to an unmatchedChildis.
                // System.out.format( "Child %d/%d of this tree %s matched child %d\n",
                //        myChildi, t.getChildCount(), getNodeText( t.getChild(myChildi), true ), matchi);
                // Remove the matchi from the unmatchedChildis
                unmatchedChildis.remove((Integer) matchi); // remove integer, not index!
            }
        }
        // All tree childis matched something in that
        // What about extras in unmatched childis?
        return true;
    }

    /**
     * Matches one of the children of that. Returns child integer of match or -1 for no match.
    */
    public static int matchTreeFirstChild(final Tree t, final Tree that, final List<Integer> childis) {
        for (int i : childis) {
            if (matchTree(t, that.getChild(i))) {
                return i;
            }
        }
        return -1;
    }

    /**
     * Given an army list with multiple choices
     * (eithers, ors, etc.),
     * Provide a list of possible permutations.
     * @return List of Army Strings, suitable for parsing.
     */
    public List<String> permute() {
        LOGGER.fine(tree.toStringTree(parser)); // print LISP-style tree
        // Permute all the slots, for example
        // List.of("Gen"), List.of("Cv+LH"), List.of("4xAx","2xBd"), List.of("3xBw","3xCb","3xLb")
        ParseTree exprs = this.tree;
        int childCount = exprs.getChildCount();
        List<List<String>> slots = new ArrayList<>();
        String listDelim = ","; // not using symbolic name of LIST_DELIM since exprs might be "Ps"
        for (int i = 0; i < childCount; i++) {
            Tree child = exprs.getChild(i);
            if ( !listDelim.equals( child.toString() ) )
                slots.add( permuteTree( child ) ); // gets terminal
        }

        // Take exprs lists and perform permuting.
        return countOff( 0, slots, listDelim );
    }

    /** Given a List of List<String>, treats each list as
     * a digit and counts them off.
     * For example List.of(List.of("1","2")) returns List.of("1","2")
     * and List.of( List.of("4","5"), List.of("1","2","3")) returns
     * List.of("4,1","4,2","4,3","5,1","5,2","5,3")
     * * @param level
     * @param stringList a list of "digits" to count for example List.of(List.of("1","2"))
     * @return a List of String which results from the counting for example List.of("1","2")
     */
    public static List<String> countOff( int level, final List<List<String>> stringList, String delim ) {
        if ( 1 + level == stringList.size() )
            return stringList.getLast();
        else {
            List<String> permutes = new ArrayList<>();
            List<String> thisLevel = stringList.get( level );
            List<String> nextLevel = countOff( level + 1, stringList, delim );
            for ( String thisStr : thisLevel ) {
                for (String nextStr : nextLevel) {
                    permutes.add( thisStr + delim + nextStr);
                }
            }
            return permutes;
        }
    }

    /**
     * Given a parse Tree with multiple choices
     * (eithers, ors, etc.),
     * Provide a list of possible permutations.
     * @return List of Army Strings, suitable for parsing.
     */
    public static List<String> permuteTree(final Tree tree) {
        // Categorize and permute. May recurse or continue to children.
        switch (tree) {
            // case DBAArmyParser.ExprsContext exprs -> {
            // Done in caller
            // }
            // case DBAArmyParser.ExprContext expr -> {
            // System.out.println("Permuting expr " + getNodeText( expr, true);
            // }
            case DBAArmyParser.ExprTypeContext exprType -> {
                // System.out.println("Permuting exprType " +  exprType.getText());
                return List.of(exprType.getText());
            }
            case DBAArmyParser.ExprGroupContext exprGroup -> {
                System.out.println("Permuting exprGroup");
                return permuteTree( exprGroup.expr());
            }
            case DBAArmyParser.ExprDismountContext dismount -> {
                System.out.println("Permuting exprDismount " +  getNodeText( dismount, true));
                if ( 3 == dismount.getChildCount() ) {
                    String dismountDelim = dismount.DISMOUNT_DELIM().getText();
                    List<String> firstList = permuteTree(dismount.expr(0));
                    List<String> secondList = permuteTree( dismount.expr(1) );
                    return countOff( 0, List.of( firstList, secondList ), dismountDelim );
                }
                throw new IllegalStateException( "exprDismount does not have three children");
            }
            case DBAArmyParser.ExprAndContext exprAnd -> {
                int childCount = exprAnd.getChildCount();
                String childCountStr = ", " + childCount + (1==childCount ? " child." : " children.");
                System.out.println("Permuting exprAnd" + childCountStr );
                List<String> firstList = permuteTree( exprAnd.expr(0) );
                if ( 3 == childCount) {
                    String andDelim = exprAnd.AND_DELIM().getText();
                    List<String> secondList = permuteTree( exprAnd.expr(1) );
                    return countOff( 0, List.of(firstList, secondList), andDelim );
                    // Stream<String> secondItems = secondList.stream();
                    // List<String> zippedTogether = andList.stream() // Java 23 preview gatherer
                    //     .gather(zip(secondItems).with((andItem,secondItem) -> andItem + andToken + secondItem))
                    //     .toList();
                }
            }
            case DBAArmyParser.ExprEitherUnitContext exprEitherUnit -> {
                int childCount = exprEitherUnit.getChildCount();
                String childCountStr = ", " + childCount + (1==childCount ? " child." : " children.");
                System.out.println("Permuting exprEitherUnit" + childCountStr );
                int firstUnitNum = Integer.parseInt(exprEitherUnit.INTEGER().getText());
                String typeText = exprEitherUnit.type().getText();
                List<String> numUnit = getNumCharGroups( typeText );
                return List.of( firstUnitNum + numUnit.getLast(), typeText);
            }
            case DBAArmyParser.ExprEitherContext exprEither -> {
                int childCount = exprEither.getChildCount();
                String childCountStr = ", " + childCount + (1==childCount ? " child." : " children.");
                System.out.println("Permuting exprEither" + childCountStr );
                List<String> firstList = permuteTree( exprEither.expr(0) );
                if ( 3 == childCount) {
                    // String eitherDelim = exprEither.EITHER_DELIM().getText();
                    List<String> secondList = permuteTree( exprEither.expr(1) );
                    // return countOff( 0, List.of(firstList, secondList), eitherDelim );
                    return Stream.concat(firstList.stream(), secondList.stream()).toList(); // concat two immutable lists
                }
                return firstList;
            }
            case DBAArmyParser.ExprOrContext exprOr -> {
                int childCount = exprOr.getChildCount();
                String childCountStr = ", " + childCount + (1==childCount ? " child." : " children.");
                System.out.println("Permuting exprOr" + childCountStr );
                List<String> firstList = permuteTree( exprOr.expr(0) );
                if ( 3 == childCount) {
                    // String orDelim = exprOr.OR_DELIM().toString(); // Why is OR_DELIM a list?
                    List<String> secondList = permuteTree( exprOr.expr(1) );
                    return Stream.concat(firstList.stream(), secondList.stream()).toList(); // concat two immutable lists
                }
                return firstList;
            }
            // might want to match 3Wb or 4Wb and 3Wb/4Wb
            case DBAArmyParser.ExprMultipleContext mult -> {
                // System.out.println("Permuting exprMulti " + getNodeText(mult, true));
                int multi = Integer.parseInt(mult.INTEGER().getText());
                String multDelim = mult.MULTIPLE_DELIM().getText();
                if ( 3 == mult.getChildCount() ) {
                    List<String> permutations = permuteTree(mult.expr());
                    return permutations.stream().map(str-> multi + multDelim + str).toList();
                }
                throw new IllegalStateException( "exprMultiple does not have three children");
            }
            case TerminalNode terminalNode -> {
                // This rule only hits exprs child token matching, ie ","
                // Can use DBAArmyLexer.VOCABULARY.getLiteralNames() or .getSymbolicNames() for the list
                // "'Hd'", "'Art'", "'WWg'", "','", "'x'", "'//'", "'/'", "'or'", "'+'", // example literal names
                // "EITHER_DELIM", "OR_DELIM", "AND_DELIM", "GROUP_OPEN", "GROUP_CLOSE", "INTEGER", "WS" // example symbolic
                // System.out.println("Matching terminal " + getNodeText(t, true) + " to " + getNodeText(that, true));
                return List.of( terminalNode.getText() );
            }
            // Army does not get here since the constructor throws IllegalArgumentException
            // else if ( t instanceof ErrorNode) {
            //    return t.toString();
            // }
            default -> System.out.println("Unknown tree " + toStringTree(tree));
        }
        return List.of();
    }

    // Testing out some permutation algorithms
    // https://www.baeldung.com/java-array-permutations
    public static <T> void printAllRecursive(T[] elements, String delimiter) {
        printAllRecursive(elements.length, elements, delimiter);
    }

    public static <T> void printAllRecursive(int n, T[] elements, String delimiter) {
        if(n == 1) {
            printArray(elements, delimiter);
        } else {
            for(int i = 0; i < n-1; i++) {
                printAllRecursive(n - 1, elements, delimiter);
                if(n % 2 == 0) {
                    swap(elements, i, n-1);
                } else {
                    swap(elements, 0, n-1);
                }
            }
            printAllRecursive(n - 1, elements, delimiter);
        }
    }

    private static <T> void swap(T[] elements, int a, int b) {
        T tmp = elements[a];
        elements[a] = elements[b];
        elements[b] = tmp;
    }

    private static <T> void printArray(T[] elements, String delimiter) {
        // String delimiterSpace = delimiter + " ";
        for (int i = 0; i < elements.length; i++) {
            System.out.print(elements[i]);
            if ( i < elements.length - 1)
                System.out.print(delimiter);
        }
        System.out.println();
    }

    public static <T extends Comparable<T>> void printAllOrdered(
            T[] elements, String delimiter) {
        Arrays.sort(elements);
        boolean hasNext = true;
        while(hasNext) {
            printArray(elements, delimiter);
            int k = 0, l = 0;
            hasNext = false;
            for (int i = elements.length - 1; i > 0; i--) {
                if (elements[i].compareTo(elements[i - 1]) > 0) {
                    k = i - 1;
                    hasNext = true;
                    break;
                }
            }
            for (int i = elements.length - 1; i > k; i--) {
                if (elements[i].compareTo(elements[k]) > 0) {
                    l = i;
                    break;
                }
            }
            swap(elements, k, l);
            Collections.reverse(Arrays.asList(elements).subList(k + 1, elements.length));
        }
    }
}